# LT Genius APIs


<!-- WARNING: THIS FILE WAS AUTOGENERATED! DO NOT EDIT! -->

[LTG - DOCs -
ReadMe](https://cirruslabsio.sharepoint.com/:w:/s/AICOE-CL-GRP/EdsWQvZUZJBKgNqYBWBD6SIBFn2jPNAk_BckVlcRR0m-Cw?e=ChQ40m0)

## APIs

- Control API: The API splits the controls from the standard and applies
  an embedding process, followed by Cosine Similarity on the controls’
  vector. This allows the API to Merge Control’s Content and generate a
  new set of controls. Finally, the API generates a JSON output with the
  new set of controls.

- Policy API: The API splits the controls from the standard and applies
  an embedding process. It then performs Cosine Similarity on the
  controls’ vector and merges the controls’ content, ultimately
  generating a new set of policies as output.

- Control GAP Analyzer: The API splits the controls from the standard
  and applies an embedding process. The system then identifies gaps in
  the controls by comparing the embedded controls with the policy,
  categorizing them as 70% \<= Matched, 70-50% = GAP, and 50%\> Missing.
  Finally, the system generates a ZIP (GAP_JSON) output containing the
  gap analysis report.

- Policy GAP Analyzer: The API splits the controls from the standard and
  then compares each control against the given policy. This allows the
  system to generate a gap analysis report, which is output as a ZIP
  (GAP_JSON) file.

[Azure
DevOps](https://dev.azure.com/CirrusLabsData/CirrusAI/_git/cirrusai-It-genius-api)

## GIT Branches

- dev -\> Dev sync
- staging -\> Development Build
- main -\> Production Build

## Installation

### Setting up the environment

``` shell
pyenv install 3.11.0
pyenv shell 3.11.0
poetry config virtualenvs.create true
poetry env use ~/.pyenv/versions/3.11.0/bin/python
poetry install
poetry shell
```

### Running with docker-compose Locally

This project folder includes a Dockerfile and docker-compose.yml that
allows you to easily build and host your LangServe app.

To run the image, you’ll need to include any environment variables
necessary for your application. Create .env file from.env.template and
populate the values.

``` shell
docker-compose build
docker-compose up -d
docker-compose down
```

### Running Locally with Poetry

``` shell
pyenv install 3.11.0
pyenv shell 3.11.0
poetry config virtualenvs.create true
poetry env use ~/.pyenv/versions/3.11.0/bin/python
poetry install
poetry shell
make start
```

### Running locally with conda env

conda activate <name of your virtual env created using conda>

### Running Lint and fromating (optional - recomended before pushing to remote)

``` shell
make lint
make format
```

### Running Unit Test (optional - recomended before pushing to remote)

``` shell
make test
```

### Mock job storage for demo purposes

``` python
mock_jobs = {
    "12345": {
        "status": "completed",
        "start_time": "2024-08-21T10:00:00Z",
        "end_time": "2024-08-21T10:15:00Z",
        "errors": []
    },
    "67890": {
        "status": "running",
        "start_time": "2024-08-21T10:00:00Z",
        "end_time": None,
        "errors": []
    },
}
```

# Deployment Guide

## **LTG Tech stack**

- **Python**: Language
- **FastAPI**: Framework for API
- **LangChain**: Integrate/ Manage LLM Agents
- **nbDev**: Code Documentation & unit-testing
- **pyTest**: Unit-Testing
- **Poetry**: dependencies management
- **MakeFile**: shell execution & env setup
- **GIT**: Code Management
- **Azure**: Cloud Service
- **Azure DevOps**: Git Repositories
- **Docker**: Containerize App
- **Kubernetes/AKS**: Manage Containers
- **Blob Storage**: Storing Policy/Controls Output
- **Elasticsearch**: Database

### Git Flow:

- **dev** -\> complete code for each sprint
- **staging** -\> deploy on staging
- **prod** -\> deploy on production env

### Must have:

- Dcoument each for function with nbdev
  - nbdev_preview -\> code doc preview
- Add a sample function execution
- Test-cases for each funtion
- create brach name \[ticket-no\]/\[short-task-name\] like
  **LG-346/generate-policies**
- create PR to dev branch
- 
